#!/usr/bin/env python3

import json
import sys
import argparse
import os
import utils.ipv4

template = r"""#!/usr/bin/env python3

# Custom topology for Mininet, generated by gentopo.py.

from mininet.topo import Topo
from mininet.net import Mininet
from mininet.node import RemoteController
from mininet.node import Node
from mininet.node import OVSSwitch
from mininet.link import TCLink
from mininet.cli import CLI
from mininet.log import setLogLevel
from mininet.util import dumpNodeConnections
from functools import partial
from collections import defaultdict, OrderedDict
import utils.ipv4
class Mynet(Topo):
    def build(self):
        switches = {}
        def add(l: int, subnet: str, *names: str):
            for i, name in enumerate(names):
                host = self.addHost(name, ip=utils.ipv4.get_nth_host(subnet, i))
                switch = self.addSwitch("s{}".format(i + l + 1))
                switches[name] = switch
                self.addLink(host, switch)

        def link(s1: str, s2: str, delay: int):
            self.addLink(switches[s1], switches[s2], bw=10, delay="{}ms".format(delay))

"""
epilogue = """
# the following code produces an executable script working with a remote controller
# and providing ssh access to the the mininet hosts from within the ubuntu vm
controller_ip = ''

def setupNetwork(controller_ip):
    "Create network and run simple performance test"
    # check if remote controller's ip was set
    # else set it to localhost
    topo = Mynet()
    switch = partial(OVSSwitch, protocols='OpenFlow10')
    if controller_ip == '':
        #controller_ip = '10.0.2.2';
        controller_ip = '127.0.0.1';
    net = Mininet(topo=topo, switch=switch, controller=lambda a: RemoteController( a, ip=controller_ip, port=6633 ), link=TCLink)
    return net

def connectToRootNS( network, switch, ip, prefixLen, routes ):
    "Connect hosts to root namespace via switch. Starts network."
    "network: Mininet() network object"
    "switch: switch to connect to root namespace"
    "ip: IP address for root namespace node"
    "prefixLen: IP address prefix length (e.g. 8, 16, 24)"
    "routes: host networks to route to"
    # Create a node in root namespace and link to switch 0
    root = Node( 'root', inNamespace=False )
    intf = TCLink( root, switch ).intf1
    root.setIP( ip, prefixLen, intf )
    # Start network that now includes link to root namespace
    network.start()
    # Add routes from root ns to hosts
    for route in routes:
        root.cmd( 'route add -net ' + route + ' dev ' + str( intf ) )

def sshd( network, cmd='/usr/sbin/sshd', opts='-D' ):
    "Start a network, connect it to root ns, and run sshd on all hosts."
    switch = network.switches[ 0 ]  # switch to use
    ip = '10.123.123.1'  # our IP address on host network
    routes = [ '10.0.0.0/8' ]  # host networks to route to
    connectToRootNS( network, switch, ip, 8, routes )
    for host in network.hosts:
        host.cmd( cmd + ' ' + opts + '&' )

    dumpNodeConnections(network.hosts)

    CLI( network )
    for host in network.hosts:
        host.cmd( 'kill %' + cmd )
    network.stop()




# by zys
def start_network(network):
    network.start()

    dumpNodeConnections(network.hosts)

    CLI( network )
    network.stop()

if __name__ == '__main__':
    setLogLevel('info')
    #setLogLevel('debug')
    # sshd( setupNetwork(controller_ip) )
    start_network(setupNetwork(controller_ip))
"""
nodes: dict[str, list[str]] = None

links: list[tuple[str, str, int]] = None


parser = argparse.ArgumentParser("gentopo.py")
parser.add_argument("-i", "--input", required=True, help="input file.")
parser.add_argument("-o", "--output", required=True, help="output name. the topo for Mininet will be saved as OUTPUT.py, the topo for VeriFlow will be saved as OUTPUT.txt")

if __name__ == "__main__":
    args = parser.parse_args(sys.argv[1:])
    with open(args.input) as f:
        obj = json.load(f)
    nodes = obj["nodes"]
    links = obj["links"]
    gateways = obj["gateways"]
    slinks = [None]
    sip = {}
    switch_nets = [None]
    
    # Generate topo
    with open(f"{args.output}.py", "w") as f:
        f.write(template)
        l = 0
        for subnet in nodes:
            for i in range(len(nodes[subnet])):
                slinks.append([(utils.ipv4.get_nth_host(subnet, i), 0)])
                sip[nodes[subnet][i]] = l + i + 1
                switch_nets.append(subnet)
            f.write('        add({}, "{}", "{}")\n'.format(l, subnet, '", "'.join(nodes[subnet])))
            l += len(nodes[subnet])
        f.write('\n')
        for link in links:
            f.write('        link("{}", "{}", {})\n'.format(link[0], link[1], link[2]))
            slinks[sip[link[0]]].append(("20.0.0.{}.{}".format(str(1000 + sip[link[1]])[1:], sip[link[1]]), link[2]))
            slinks[sip[link[1]]].append(("20.0.0.{}.{}".format(str(1000 + sip[link[0]])[1:], sip[link[0]]), link[2]))
        f.write('\n')
        f.write(epilogue)
    
    os.chmod(f"{args.output}.py", 0o755)
    
    # Generate config for VeriFlow
    with open(f"{args.output}.txt", "w") as f:
        f.write("# switches\n")
        for i in range(1, len(slinks)):
            f.write("{} 20.0.0.{}.{} 0".format(i,str(1000 + i)[1:], i))
            for j, link_info in enumerate(slinks[i]):
                f.write(f" {j + 1} {link_info[0]}")
            # write delay in comment
            f.write(" # delay(ms):")
            for link_info in slinks[i]:
                f.write(f" {link_info[1]}")
                if not link_info[0].startswith("20"):
                    f.write("h")
                else:
                    peer_id = int(link_info[0].split(".")[-1])
                    if switch_nets[i] != switch_nets[peer_id]:
                        f.write("e")
                    else:
                        f.write("i")
            f.write("\n")

        f.write("\n# hosts\n")
        for i in range(1, len(slinks)):
            f.write("{} {} 1 0 20.0.0.{}.{}\n".format(100 + i, slinks[i][0][0], str(1000 + i)[1:], i))

    # Generate routing config, a BGP-like config
    routing_config = {
        "switch_nets": switch_nets, # switch_dpid: network
        "gateways": {}, # gateways: src_net : { dst_net : list[gateway] }
        "peers": {} # peers: gateway_dpid : { dst_net : peer_dpid }
    }
    for src_net in gateways:
        routing_config["gateways"][src_net] = {}
        
        for dst_net in gateways[src_net]:
            switches = []
            routing_config["gateways"][src_net][dst_net] = switches
            
            for route in gateways[src_net][dst_net]:
                gw = sip[route["via"]]
                nxt = sip[route["next"]]
                
                if gw not in routing_config["peers"]:
                    routing_config["peers"][gw] = {}
                routing_config["peers"][gw][dst_net] = nxt
                
                switches.append(gw)
                
            routing_config["gateways"][src_net][dst_net] = switches
    
    with open(f"{args.output}.config.json", "w") as f:
        json.dump(routing_config, f)